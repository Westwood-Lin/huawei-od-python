# 141-构成的正方形数量

[TOC]



## 题目

输入N个互不相同的二维整数坐标（即N个点），求这N个坐标可以构成的正方形数量。



## 输入

* 第一行输入为`N`，代表坐标数量（即点数），`N`为正整数，且`N<=100`
* 之后的`N`行输入为`x y`，`x` 和`y`为整数，且以空格分隔，均满足：`-10 <= x,y <=10`



## 输出描述

输出N个点可以构成的正方形数量



## 示例

### 示例一

**输入：**

```
3
1 3
2 4
3 1
```

**输出：**

```
0
```



### 示例二

**输入：**

```
4
0 0
1 2
3 1
2 -1
```

**输出：**

```
1
```



### 示例三（补充）

**输入：**

```
5
0 0
1 2
3 1
2 -1
1 1
```

**输出：**

```
1
```



### 示例四（补充）

**输入：**

```
7
0 0
1 2
3 1
2 -1
1 1
1 0
0 1
```

**输出：**

```
2
```





## 解题思路

### 方法一（每次选4个点判断）

1. 首先，我们**处理输入**，保存`N`个点的坐标到一个列表里。因为每个坐标有x、y两个值，所以可以用python的`元组/列表/两个int的类`来保存它们。
2. 其次，我们得到`N`个点的坐标以后，需要**循环执行两个步骤**
   - 从`N`个点里**选出4个点**来（选出点的组合，不能重复）
   - 判断4个点能否形成正方形
     - 具体如何判断正方形？我们可以单独使用一个`is_square()`方法来判断4个点能否形成正方形
     - 如果4个点形成正方形，那个数计数就加1

   - 当不能再选出新的点的组合时，循环结束，返回正方形个数。

3. 那么`is_square()`方法如何实现？
   - 我们有4个点的坐标，每两个点之间可以形成一条边，就有 4*3/2=6条边。
   - 正方形的四个顶点之间正好有**四条边**，**两条对角线**，4+2 也就是这6条边。同时正方形的对角线长度是边的根号2倍。
   - 所以我们可以**计算得到6条边的长度**，如果这6条边里的**4条短边之间长度相等**，说明这四条短边就是正方形的四边。而**两条长边之间也长度相等**，说明这四个顶点可以形成正方形。


> 原答案里只说判断4条边相等且不为0，就可以构成正方形，这是错误的。
>
> 因为菱形也满足四条边相等。
>
> 正方形比起菱形，还要多一个对角线相等。



4. 那么怎么从`N`个点里依次选出4个点来呢？
   - 最简单的想法就是一个用四重循环

```python
...
points=[]
...
for i in range(n-3):
    for j in range(i+1,n-2):
        for k in range(j+1,n-1):
            for p in range(k+1,n):
                if(is_square(points[i],points[j],points[k],points[p])):
                    # 4个点构成正方形则计数+1
                    count += 1
```





- 该方法的时间复杂度（从N个点选4个点需要用到排列组合的组合数知识）

$$
四重循环： C_N^4=(_4^N)=\frac{N(N-1)(N-2)(N-3)}{4*3*2*1}=\frac{N^4+...}{24}\le 10^7
\\
算法的时间复杂度大概是O(N^4)
$$

这个时间复杂度很大。幸好已知 `N 不超过 100`，在时间要求不紧张的情况下，使用这种直接的办法也是不错的选择。



#### 解题代码

```python
from typing import List

def is_square(point1: List[int], point2: List[int], point3: List[int], point4: List[int]) -> bool:
    """
     :param point1: 第一个点的坐标，需要是列表类型，列表长度需要为2
     :param point2: 第二个点; 后两个参数以此类推
     :return: 四个点可否构成正方形
     """

    points = [point1, point2, point3, point4]
    distances = []

    # 每个点两两之间形成一条边，计算这些边的长度(的平方)，保存到 distances 里
    for i in range(3):
        for j in range(i + 1, 4):
            x, y = points[i][0] - points[j][0], points[i][1] - points[j][1]
            distance = x * x + y * y
            distances.append(distance)

    # 按边的长度排序，默认是升序
    distances.sort()

    # 条件1：四条边长度相等（保证是菱形）
    condition1 = (distances[0] == distances[1]) and (distances[1] == distances[2]) and (
            distances[2] == distances[3])

    # 条件2：两条对角线长度相等（一个菱形的两条对角线相等，那么这个菱形就是正方形）
    condition2 = (distances[4] == distances[5])

    # 同时满足两个条件才是正方形（返回True）
    return condition1 and condition2


def solve_method():
    # 1. 处理输入
    n = int(input())
    points = []
    for i in range(n):
        # input().split()的结果是 一个字符串列表["0","0"]
        # 我们使用 map(int,input().split())，即对input().split()的里的每个元素执行 int()，即转化为int类型
        # x,y = (int("0"),int("0")) = 0,0
        x, y = map(int, input().split())
        points.append([x, y])

    # 2.计算能构成多少个正方形
    count = 0
    # 通过四重循环来不重复地挑选 4个点，通过调用 is_square 判断是否构成正方形
    for i in range(n - 3):
        for j in range(i + 1, n - 2):
            for k in range(j + 1, n - 1):
                for p in range(k + 1, n):
                    if is_square(points[i], points[j], points[k], points[p]):
                        count += 1
    
    # 3.打印输出
    print(count)
```



> 注意，在对应的代码实现中（即文件`141_Number_of_squares.py`中)，为了便于写`unittest`测试，将solve_method处理输入的部分转移到了main方法里。但实际上是相同的实现。





### 其他方法

该题跟数学关系很大，解法很多。

它的关键在于两点，第一怎么从N个点里挑选出点的组合，第二判断这个点的组合能不能构成正方形。我们如果从N个点里选出4个点来，4个点、4个点地进行判断，时间复杂度就是O(N^4)，这在N不大的时候是可行的。

但其实我们可以每次选点只选3个，进行更多的分析。这样的好处在于降低时间复杂度，但是会大大增加代码实现的难度。



比如：

#### 每个组合选三个点

对于4个点`[(0,0),(0,1),(1,0),(1,1)]`，我们可以选出3个点`(0,0),(0,1),(1,0)`，计算得到3条边 00到01，00到10，01到10，长度分别为1，1，根号2。

我们发现有两条边相等，长边的长度是短边的根号2倍，说明这三个点是可能构成正方形的。我们再加上一个合适的点就可以构成正方形。而且我们已经确定了边的长度。

实际上，如果确定三个点可以构成一个正方形，那最后一个点的位置是确定和唯一的。我们用高中数学里关于向量的知识就可以得到它。如果得到了这个点，判断它是否在我们的输入坐标里，如果在，那就可以构成一个正方形。



而对于4个点`[(0,0),(0,1),(2,0),(1,1)]`，我们选出3个点`(0,0),(0,1),(2,0)`，计算3条边 00到01，00到20，01到20，长度分别为1，2，根号5。这就表明这三个点不可能构成正方形。所以我们跳过这种可能，不用管最后一个点。

我们每次选3个点就判断，可以提前进行一次筛选，效率当然是比选出4个点再判断高。



#### 每个组合选两个点

我们设两个点为(x1,y1),(x2,y2)。

同样用高中数学的向量运算，我们可以用这四个变量x1，x2，y1，y2来表示其他两个顶点。

接下来可以枚举一些变量值，判断对应的顶点是否在输入里。



### 注

显然，这个问题是一个比较基础的问题。

因为`N`的最大值都很小，在能AC的前提下，使用最直接的四重循环未尝不可，还可以节省时间、避免在复杂做法的细节处出错。
